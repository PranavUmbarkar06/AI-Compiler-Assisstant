<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Compiler Assistant — Clean Layout</title>

  <!-- CodeMirror -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.14/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.14/theme/dracula.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.14/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.14/mode/python/python.min.js"></script>

  <!-- Markdown renderer + sanitizer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>

  <style>
    :root {
      --bg: #0b0e14;
      --panel: #071017;
      --muted: #8b949e;
      --accent: #ff7b59;
    }
    html,body { height:100%; }
    body {
      font-family: Arial, sans-serif;
      background: var(--bg);
      color: #e6eef6;
      margin:0;
      display:flex;
      flex-direction:column;
      align-items:center;
    }
    header { width:100%; text-align:center; padding:20px 12px; background:#0f1724; border-bottom:1px solid #111827; }
    header h1 { margin:0; color:var(--accent); font-size:22px; }
    main { width:92%; max-width:1000px; margin:20px auto; display:flex; flex-direction:column; gap:14px; }
    .panel { background: var(--panel); padding:12px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); overflow:auto; }
    #editor-container { display:flex; flex-direction:column; height:55vh; }
    .CodeMirror { height:100%; border-radius:6px; font-size:15px; outline: none; }
    .controls { margin-top:10px; display:flex; gap:8px; justify-content:flex-end; }
    button { padding:8px 12px; border-radius:8px; border:0; cursor:pointer; font-weight:600; font-size:13px; }
    button.run { background:#16a34a; color:white; } button.clear { background:#ef4444; color:white; }
    #output { background:#000; color:#00ff7f; padding:10px; border-radius:6px; font-family:monospace; white-space:pre-wrap; min-height:140px; }
    #assistant { color:#dbefff; font-size:14px; white-space:pre-wrap; }
    footer { margin:18px 0 36px; color:var(--muted); font-size:13px; }

    /* Assistant markdown styling */
    #assistant h1, #assistant h2, #assistant h3 { color:#bfe7ff; margin:6px 0; }
    #assistant pre { background:#05111a; padding:8px; border-radius:6px; overflow:auto; color:#d8f3ff; }

    /* Fancy corrected code box (techy) */
    .corrected-wrap { margin-top:12px; display:flex; gap:10px; align-items:flex-start; justify-content:space-between; }
    .corrected-left { flex:1; }
    .corrected-title { display:inline-block; background:linear-gradient(90deg,#0ea5a9 0%, #60a5fa 100%); color:#042027; padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px; margin-bottom:8px; }
    .corrected-code-box { background: linear-gradient(180deg, rgba(6,10,14,0.9), rgba(8,12,18,0.9)); border: 1px solid rgba(96,165,250,0.06); padding:12px; border-radius:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace; white-space: pre; color: #d1eaff; overflow:auto; font-size:13px; }

    /* Small action area */
    #assistant-actions { margin-top:10px; display:flex; justify-content:flex-end; gap:8px; align-items:center; }
    .btn-primary { background:#2563eb;color:#fff;padding:8px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700; }
    .btn-ghost { background:transparent;color:#dbefff;padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);cursor:pointer; }

    /* confirmation card */
    .replace-confirm { margin-top:10px; padding:10px; border-radius:8px; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .transient-note { color:#a7f3d0; font-size:13px; margin-left:8px; }
  </style>
</head>

<body>
  <header><h1>AI Compiler Assistant</h1></header>

  <main>
    <div class="panel" id="editor-container">
      <textarea id="code" placeholder="enter code here...">integer a=5</textarea>
      <div class="controls">
        <button id="run" class="run">Run ▶</button>
        <button id="clear" class="clear">Clear ✖</button>
      </div>
    </div>

    <div class="panel">
      <strong>Output</strong>
      <div id="output">(no output yet)</div>
    </div>

    <div class="panel">
      <strong>Assistant</strong>
      <div id="assistant">(no assistant output)</div>
      <!-- assistant-actions appended by script -->
    </div>
  </main>

  <footer>© 2025 AI Compiler Assistant | Simple & clean layout</footer>

<script>
  // CodeMirror init
  const editor = CodeMirror.fromTextArea(document.getElementById('code'), {
    mode: "python",
    theme: "dracula",
    lineNumbers: true,
    indentUnit: 2,
    tabSize: 2
  });
  editor.setSize("100%", "100%");

  const runBtn = document.getElementById('run');
  const clearBtn = document.getElementById('clear');
  const outputEl = document.getElementById('output');
  const assistantEl = document.getElementById('assistant');

  // action area
  const assistantActions = document.createElement('div');
  assistantActions.id = 'assistant-actions';
  assistantActions.style.marginTop = '8px';
  assistantActions.style.display = 'none';
  assistantEl.parentNode.appendChild(assistantActions);

  function setOutput(text, isError=false){
    outputEl.textContent = text || '';
    outputEl.style.color = isError ? '#ff7a7a' : '#00ff7f';
  }

  function escapeHtml(s){
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  // Improved extractor: returns ONLY the code text or null
  function extractCorrectedCode(rawText) {
    if (!rawText) return null;

    // remove bold markers that might appear around titles
    rawText = rawText.replace(/\*\*/g, '');

    // 1) fenced code block priority
    let m = rawText.match(/```(?:[\w+-]*)\n?([\s\S]*?)```/);
    if (m && m[1].trim()) {
      return m[1].trim();
    }

    // 2) "Corrected Code" label: take everything after it
    m = rawText.match(/Corrected\s*Code\s*[:\-]?\s*[\r\n]*([\s\S]*)$/i);
    let candidate = m ? m[1] : rawText;

    if (!candidate || !candidate.trim()) return null;

    // split into lines and pick only code-like lines
    const lines = candidate.split(/\r?\n/);
    const codeLike = lines.filter(line => {
      const t = line.trim();
      if (!t) return false;
      // drop lines that look like section headers or plain explanation
      if (/^(errors|explanation|fix|optimization)\b/i.test(t)) return false;
      if (/^\*+$/.test(t)) return false; // stray ****
      // keep lines that contain semicolon, equals sign, parentheses (print), or the 'integer' keyword,
      // or start with typical identifiers followed by assignment
      if (/[;=()]/.test(t)) return true;
      if (/\binteger\b/i.test(t)) return true;
      if (/^\s*[a-zA-Z_]\w*\s+[a-zA-Z_]\w*\s*;?$/.test(t)) return true; // e.g., "int a;"
      if (/^\s*print\s*\(.*\)\s*;?$/.test(t)) return true;
      // else discard
      return false;
    });

    // If we found contiguous code-like lines, collapse consecutive groups and return longest group
    if (codeLike.length) {
      // sometimes non-code lines are interspersed; better to take contiguous groups from original lines
      let groups = [];
      let cur = [];
      for (const line of lines) {
        const t = line.trim();
        if (!t) {
          if (cur.length) { groups.push(cur.slice()); cur = []; }
          continue;
        }
        // criteria same as filter
        if (/[;=()]/.test(t) || /\binteger\b/i.test(t) || /^\s*print\s*\(.*\)\s*;?$/.test(t) || /^\s*[a-zA-Z_]\w*\s+[a-zA-Z_]\w*\s*;?$/.test(t)) {
          cur.push(line);
        } else {
          if (cur.length) { groups.push(cur.slice()); cur = []; }
        }
      }
      if (cur.length) groups.push(cur.slice());

      // choose largest group (most lines)
      if (groups.length) {
        groups.sort((a,b)=>b.length-a.length);
        return groups[0].join('\n').trim();
      }
      // fallback to codeLike join
      return codeLike.join('\n').trim();
    }

    // fallback: remove stray markers and return candidate
    const cleaned = candidate.replace(/^\s*[-\*\s]+$/gm, '').replace(/\*\*/g,'').trim();
    return cleaned || null;
  }

  // Render assistant (markdown -> sanitized html) and append cleaned corrected code box only if code exists
  function renderAssistant(assistantData){
    assistantActions.style.display = 'none';
    assistantActions.innerHTML = '';

    if (!assistantData){
      assistantEl.innerHTML = '(no assistant output)';
      return;
    }

    let rawText = "";
    if (typeof assistantData === 'object'){
      if (typeof assistantData.assistant === 'string')
        rawText = assistantData.assistant;
      else
        rawText = JSON.stringify(assistantData, null, 2);
    } else if (typeof assistantData === 'string'){
      rawText = assistantData;
    } else {
      rawText = String(assistantData);
    }

    // render sanitized markdown for the user-visible explanation
    try {
      assistantEl.innerHTML = DOMPurify.sanitize(marked.parse(rawText));
    } catch (e) {
      assistantEl.textContent = rawText;
    }

    // extract only the corrected code (clean)
    const corrected = extractCorrectedCode(rawText);

    if (corrected) {
      // append a clean corrected-code box (escaped)
      const fancy = document.createElement('div');
      fancy.className = 'corrected-wrap';

      const left = document.createElement('div');
      left.className = 'corrected-left';

      const title = document.createElement('div');
      title.className = 'corrected-title';
      title.textContent = 'Corrected Code';

      const codeBox = document.createElement('pre');
      codeBox.className = 'corrected-code-box';
      codeBox.innerHTML = escapeHtml(corrected);

      left.appendChild(title);
      left.appendChild(codeBox);
      fancy.appendChild(left);

      assistantEl.appendChild(fancy);

      // show actions: use / copy
      assistantActions.style.display = 'flex';
      assistantActions.innerHTML = `
        <div style="display:flex;gap:8px;align-items:center;">
          <button id="insert-corrected" class="btn-primary">Use corrected code</button>
          <button id="copy-corrected" class="btn-ghost">Copy</button>
        </div>
        <div id="replace-confirm" style="display:none;width:100%;margin-top:8px;"></div>
      `;

      document.getElementById('insert-corrected').addEventListener('click', () => {
        const rc = document.getElementById('replace-confirm');
        rc.style.display = 'flex';
        rc.className = 'replace-confirm';
        rc.innerHTML = `
          <div style="font-size:13px;color:#dbefff;">Replace the editor content with the AI-corrected code?</div>
          <div style="display:flex;gap:8px;">
            <button id="confirm-yes" class="btn-primary">Yes — replace</button>
            <button id="confirm-no" class="btn-ghost">No — keep current</button>
          </div>
        `;

        document.getElementById('confirm-no').addEventListener('click', () => {
          rc.style.display = 'none';
          rc.innerHTML = '';
        });

        document.getElementById('confirm-yes').addEventListener('click', () => {
          editor.setValue(corrected);
          rc.style.display = 'none';
          rc.innerHTML = '';
          const n = document.createElement('div');
          n.className = 'transient-note';
          n.textContent = 'Editor replaced with corrected code.';
          assistantActions.appendChild(n);
          setTimeout(()=> n.remove(), 2400);
        });
      });

      document.getElementById('copy-corrected').addEventListener('click', () => {
        navigator.clipboard?.writeText(corrected).then(() => {
          const n = document.createElement('div');
          n.className = 'transient-note';
          n.textContent = 'Corrected code copied to clipboard.';
          assistantActions.appendChild(n);
          setTimeout(()=> n.remove(), 1800);
        }).catch(() => {
          alert('Copy failed — you can manually select and copy the corrected code.');
        });
      });
    }
  }

  // Run button behaviour (POST /run)
  runBtn.addEventListener('click', async () => {
    const code = editor.getValue();
    if (!code.trim()) return setOutput('No code provided.', true);

    runBtn.disabled = true;
    runBtn.textContent = 'Running…';
    setOutput('Running...', false);
    assistantEl.textContent = '(waiting for assistant...)';
    assistantActions.style.display = 'none';
    assistantActions.innerHTML = '';

    try {
      const res = await fetch('/run', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ code })
      });
      const json = await res.json();

      if (json && typeof json === 'object' && ('ran' in json || 'run_result' in json || 'assistant' in json)){
        if (json.ran){
          const runResult = json.run_result || {};
          let stdout = (runResult.stdout || '').trim();
          if (runResult.symbols)
            stdout += '\n\nFinal Symbols:\n' + JSON.stringify(runResult.symbols, null, 2);
          setOutput(stdout || '(no stdout)');
          renderAssistant(json.assistant || null);
        } else {
          setOutput('Error: ' + (json.run_result?.error || 'Execution failed'), true);
          renderAssistant(json.assistant || json.run_result?.assistant || null);
        }
      } else if ('output' in json || 'error' in json){
        if (json.error && !json.output)
          setOutput('Error: ' + json.error, true);
        else
          setOutput(json.output || json.error || '(no output)', !!json.error);
        renderAssistant(json.assistant ?? null);
      } else {
        setOutput('Unexpected server response', true);
        renderAssistant(json);
      }
    } catch (err) {
      setOutput('Request failed: ' + String(err), true);
      renderAssistant(null);
    } finally {
      runBtn.disabled = false;
      runBtn.textContent = 'Run ▶';
    }
  });

  clearBtn.addEventListener('click', () => {
    editor.setValue('');
    setOutput('');
    assistantEl.textContent = '';
    assistantActions.style.display = 'none';
    assistantActions.innerHTML = '';
  });

  window.addEventListener('keydown', e => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') runBtn.click();
  });

  // dev: example to test cleaned corrected code
  // uncomment to see behavior:
  // const sample = "Errors:\\nLine 1: ...\\n\\nCorrected Code:\\ninteger a=5;\\nprint(a);\\n\\n**";
  // renderAssistant({assistant: sample});
</script>
</body>
</html>
